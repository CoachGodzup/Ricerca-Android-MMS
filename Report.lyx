#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
% VDE Template for EUSAR Papers
% Provided by Barbara Lang und Siegmar Lampe
% University of Bremen, January 2002
% English version by Jens Fischer
% German Aerospace Center (DLR), December 2005
% Additional modifications by Matthias Wei{\ss}
% FGAN, January 2009

%-----------------------------------------------------------------------------
% Type of publication

%-----------------------------------------------------------------------------
% Other packets: Most packets may be downloaded from www.dante.de and
% "tcilatex.tex" can be found at (December 2005):
% http://www.mackichan.com/techtalk/v30/UsingFloat.htm
% Not all packets are necessarily needed:
%\usepackage{ngerman} % in german language if required
\usepackage[nooneline,bf]{caption}% Figure descriptions from left margin
\usepackage{times}\usepackage{multicol}\usepackage{epsfig}\input{tcilatex}
%-----------------------------------------------------------------------------
% Page Setup
\textheight24cm \textwidth17cm \columnsep6mm
\oddsidemargin-5mm                 % depending on print drivers!
\evensidemargin-5mm                % required margin size: 2cm
\headheight0cm \headsep0cm \topmargin0cm \parindent0cm
                  % delete footer and header
%----------------------------------------------------------------------------
% Environment definitions
%-----------------------------------------------------------------------------
% Using Pictures and tables:
% - Instead "table" write "tablehere" without parameters
% - Instead "figure" write "figurehere " without parameters
% - Please insert a blank line before and after \begin{figurehere} ... \end{figurehere}
%
% CAUTION:   The first reference to a figure/table in the text should be formatted fat.
%




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding latin1
\fontencoding T1
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 2
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle empty
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Survey on Android Memory Management System
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Garza Matteo
\end_layout

\begin_layout Standard
Matr.
 755295, (matteo.garza@mail.polimi.it)
\end_layout

\begin_layout Standard
Tania Suarez Legra
\end_layout

\begin_layout Standard
Matr 748927 (tania.suarez@mail.polimi.it)
\end_layout

\begin_layout Standard
\begin_inset space \hspace{}
\length 10ex
\end_inset

 
\end_layout

\begin_layout Standard
\align right

\emph on
Report for the master course of Real Time Operative System (RTOS)
\emph default

\begin_inset Newline newline
\end_inset

 
\emph on
Reviser: PhD.
 Patrick Bellasi (bellasi@elet.polimi.it)
\emph default
 
\end_layout

\begin_layout Standard
Received: April, 01 2011
\begin_inset Newline newline
\end_inset

 
\begin_inset space \hspace{}
\length 10ex
\end_inset


\end_layout

\begin_layout Abstract
Android Operative System
\begin_inset CommandInset citation
LatexCommand cite
key "OVERVIEW"

\end_inset

 is the most diffuse OS in mobile devices.
 In this paper we will analyze how Android manages memory.
 We discuss in particular about application memory and some of the most
 used MMUs used by Android OS.
\end_layout

\begin_layout Standard
\begin_inset VSpace 4ex
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

% ASSIGNMENT:
\end_layout

\begin_layout Plain Layout

Analyze and document how the Android specific memory management systems
 work and integrate with hardware resources.
 In particular, describe how application and hardware resources are managed
 (OOM killer, PMEM and HWMEM drivers).
\end_layout

\begin_layout Plain Layout

Project Goals: Understanding the Android memory management Required skills:
 Linux kernel and UNIX process management basics Peoples: This project is
 suited for one student or a group with maximum two people.
\end_layout

\begin_layout Plain Layout

Project Status: Working on: anyone
\end_layout

\begin_layout Plain Layout

NOTE: still available for other students/groups
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{multicols}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset

2
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Kernel Memory Management
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
Android
\begin_inset CommandInset citation
LatexCommand cite
key "WIKI,OVERVIEW"

\end_inset

 is a Linux-based operative system, written in C and C++.
 Android application software runs on a framework which includes Java-compatible
 libraries.
 Android uses the Dalvik virtual machine with just-in-time compilation to
 run Dalvik dex-code (Dalvik Executable), which is usually translated from
 Java bytecode.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "Android distribution diffusion"

\end_inset

 shows the actual
\begin_inset CommandInset citation
LatexCommand cite
key "WIKI"

\end_inset

 distribution of Android version between devices with this kernel:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/coach/Dropbox/RTOS/Android_chart.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Android distribution diffusion"

\end_inset


\end_layout

\begin_layout Standard
We can notice that now the common kernel distributions still use Linux 2.6.x
 kernel.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "Android structure"

\end_inset

 shows Android System Architecture schema 
\begin_inset CommandInset citation
LatexCommand cite
key "WIKI"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/coach/Dropbox/RTOS/System-architecture.jpg
	scale 30

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Android structure"

\end_inset


\end_layout

\begin_layout Standard
Android 
\begin_inset CommandInset citation
LatexCommand cite
key "OVERVIEW"

\end_inset

 provides some modification to main Linux kernel, such as an improved power
 management, ASHMEM virtual memory, some specific-component drivers, and
 a low memory killer.
 The latter's mission is to free memory when the system run Out of Memory
 (OOM).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%-----------------------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% TODO: 
\end_layout

\begin_layout Plain Layout

 - ampliare l'introduzione
\end_layout

\begin_layout Plain Layout

 - rivedere parte su CMA: guardarsi gli altri articoli, condensare le notizie
 importanti
\end_layout

\begin_layout Plain Layout

 - finire ION con gli sviluppi futuri: integrazione CMA con ION.
\end_layout

\begin_layout Plain Layout

 - TUTTA la parte su OOM killer
\end_layout

\begin_layout Plain Layout

 - 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Low level management and integration with HW resources
\end_layout

\begin_layout Standard
In this part, we discuss about how the memory has managed in Android devices.
 For most of the releases in Android, it was used PMEM and ASHMEM.
 These kind of libraries was too simple, and was patched with some SoC patches,
 such as NVMAP for nVidia Tegra devices and CMEM for TI OMAP ones.
 The most important patch was CMA (Contiguous Memory Access), expecially
 with DMABUF patch.
 With the release of Android 4.0 (Ice Cream Sandwich) a brand new driver
 has released, ION.
 We discuss about differences between ION and CMA approach, and, in the
 state-of-art, we discuss of a future integration between them.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%-----------------------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
PMEM and ASHMEM
\end_layout

\begin_layout Standard
PMEM (Process MEMory)
\begin_inset CommandInset citation
LatexCommand cite
key "AKF"

\end_inset

 is the first memory driver implemented on Android devices (since G1).
 It is used to manage shared memory regions sufficiently large (from 1 to
 16MB).
\end_layout

\begin_layout Standard
This regions must be physically contiguous between user space and kernel
 drivers (such as GPU, or DSP).
 It was written specifically to be used in a very limited hardware platform,
 and it could be disabled on x86 architectures.
\end_layout

\begin_layout Standard
ASHMEM
\begin_inset CommandInset citation
LatexCommand cite
key "ASHMEM"

\end_inset

 (Android SHared MEMory) is a shared memory allocator subsystem, similar
 to POSIX, but with a different behavior.
 It also gives to the developer an easier and file-based API.
 It used named memory, releasable by the kernel.
 Apparently, ASHMEM supports low memory devices better than PMEM, because
 it could free shared memory units when it is needed.
 
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="33col%">
<column alignment="center" valignment="top" width="40col%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PMEM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ASHMEM
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Uses physically contiguous addresses
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Uses virtual memory
\end_layout

\end_inset
</cell>
</row>
<row endhead="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
The first process who instantiate a memory heap must keep that till the
 last one of the users won't free the file descriptor.
 Thus to preserve contiguity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Memory is handled by instances (object oriented like).
 It is managed by a reference counter
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
CMA and DMABUF
\end_layout

\begin_layout Standard
CMA (Contiguous Memory Allocator)
\begin_inset CommandInset citation
LatexCommand cite
key "CMAdoc"

\end_inset

 is a well known framework, which allows setting up a machine-specific configura
tion for physically-contiguous memory management.
 Memory for devices is then allocated according to that configuration.
 Differently from similar framework, it let regions of system-reserved memory
 to be reused in a transparent way, letting memory not to be wasted.
 When an alloc is instantiated, this framework migrates all the system page.
 Thus to build a big chunk of physically contiguous memory.
\end_layout

\begin_layout Standard
Why do an OS have to use chunks of memory?
\begin_inset CommandInset citation
LatexCommand cite
key "CMA,RCMA"

\end_inset

 Because virtual memory tends to fragment pages.
 An intensive use of memory let the system not able to find contiguous memory
 in a very short time after boot.
 Recently, the requirement of huge pages in applications raises, especially
 for transparent huge pages.
 Another question is devices (such as cameras) that needs DMA over areas
 physically contiguous.
 CMA reserve an huge area of memory at boot time, only for huge request
 of memory.
 For every region, block of pages can be flaggable as three type.
 
\end_layout

\begin_layout Itemize
movable : typically, cache pages or anonymous pages, accessed by page table
 or page cache radix tree 
\end_layout

\begin_layout Itemize
kernel recallable : they can be given back to the kernel by request.
 
\end_layout

\begin_layout Itemize
immovable : these are typically pointer referred pages (such as pages invoked
 by a kmalloc()) 
\end_layout

\begin_layout Standard
The memory manager subsystem try to keep movable pages as near as possible.
 Grouping these pages, kernel try to ensure more and more contiguous free
 space available for further request.
 CMA extends this mechanism.
 It adds a new type of migration (CMA).
 Pages flagged as cma behave like the movable ones, with some differences:
 
\end_layout

\begin_layout Itemize
they are 
\begin_inset Quotes eld
\end_inset

sticky
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Itemize
Their migration type can't be modified by the kernel 
\end_layout

\begin_layout Itemize
In CMA Area, the kernel cannot instantiate pages not movable.
\end_layout

\begin_layout Standard
In other words, memory flagged as CMA keep available for the rest of the
 system with the only restriction to be movable.
 
\end_layout

\begin_layout Standard
When a driver ask for a huge contiguous allocation of memory, CMA allocator
 can try to free in his own area some contiguous pages to create a buffer
 large as needed.
 When the buffer is no longer requested, memory can be used for other needs.
 CMA can just take only the needed amount of memory without worrying about
 strictly request of alignment.
\end_layout

\begin_layout Standard
DMA buffers has different request despise of huge pages.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="33col%">
<column alignment="center" valignment="middle" width="33col%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMABUF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Transparent Huge Pages
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Normally larger than Transparent Huge Pages.
 10 Mb.
\end_layout

\begin_layout Plain Layout
It could be needed specific memory area, if underlying hardware is sufficiently
 
\begin_inset Quotes eld
\end_inset

strange
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Almost 2Mb large
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMA requires less alignment than THP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2MB of THP needs 2Mb of Alignment
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
CMA patches provides a set of function that can prepare regions of memory
 and the creation of contest area of a well known size using function cm_alloc
 and cm_free to keep and release buffers.
 CMA must not be invoked by the driver, but from DMA support functions.
 When a driver call a function like dma_alloc_coherent(), CMA should be
 invoked automatically to satisfying the request.
 This should work in normal condition.
\end_layout

\begin_layout Standard
One of the issue about CMA is how to initially alloc this area of memory.
 Current scheme needs that some of special calls should be done by the board
 file system, with a very arm-like approach.
 The idea is to do that without board files.
 The ending result is that it should be at least one iteration of that patch
 set before it will be executed by the mainline.
 
\end_layout

\begin_layout Subsection
ION
\end_layout

\begin_layout Standard
In december 2011, PMEM is marked as deprecated, and then replaced by ION
 memory allocator
\begin_inset CommandInset citation
LatexCommand cite
key "ION"

\end_inset

.
 ION is a memory manager that Google has developed from the 4.0 release of
 Android (Ice Cream Sandwich), mainly to resolve the interface issue between
 different memory management between different Android device.
 In fact, some SoC developer implemented different memory manager.
 We can cite some of them:
\end_layout

\begin_layout Itemize
NVMAP, implemented on nVidia Tegra 
\end_layout

\begin_layout Itemize
CMEM
\begin_inset CommandInset citation
LatexCommand cite
key "CMEM"

\end_inset

, implemented on TI OMAP 
\end_layout

\begin_layout Itemize
HWMEM
\begin_inset CommandInset citation
LatexCommand cite
key "HWMEM"

\end_inset

, implemented on ST-Ericsonn devices 
\end_layout

\begin_layout Standard
All this vendor will pass to ION soon
\end_layout

\begin_layout Standard
Besides ION being a memory pool manager, it also enables his clients to
 share buffers (so, it works like DMABUF, the DMA buffer sharing framework).
 Like PMEM, ION manages one or more pools of memory, some of them instantiated
 at boot time or from hardware blocks with specific memory needs.
 Some devices like that are GPU, display controllers and cameras.
 ION let his pools to be available as heap ION.
 Every kind of android device can have different ION heaps, depending on
 device memory.
 Phisical address and heap dimension can be returned to the programmer only
 if the buffer is physically contiguous.
 Buffer can be prepared or deallocated to be used with DMA, or with virtual
 kernel addressing.
 Using a file descriptor, it can be also mapped in the user-space.
 There are three kind of allocable ION heap.
 Other ones can be defined by SoC producers (like ION_HEAP_TYPE_SYSTEM_IOMMU
 for hardware blocks equipped with IOMMU driver).
 
\end_layout

\begin_layout Itemize
ION_HEAP_TYPE_SYSTEM
\end_layout

\begin_layout Itemize
ION_HEAP_TYPE_SYSTEM_CONTIG
\end_layout

\begin_layout Itemize
ION_HEAP_TYPE_CARVEOUT : in this case, carveout memory is physically contiguous
 and set as boot.
 
\end_layout

\begin_layout Standard
Typically, in the user-space case, libraries uses ION to alloc large continuous
 buffers.
 For instance, camera library can alloc a capture buffer to be used from
 the camera device.
 Once the buffer is fulfilled with video data, the library gives the buffer
 to kernel to be processed by jpeg encoder block.
 A c/c++ program must have access to '/dev/ion' before it can alloc memory
 thanks to ION.
 He can alloc data using file descriptors (fd).
 It can be maximum one client for user process.
\end_layout

\begin_layout Standard
Clients interacts from user-space with ION using ioctl() system interface.
 Android processes can share memory using their fd.
 To obtain shared buffer, the second user process must obtain a client handle
 through a system call open('/dev/ion', O_RDONLY).
 ION manage user space client through process PID (in particular, the 'group
 leader ' one).
 Fd will be instantiated pointing at the same client structure in the kernel.
 To free a buffer, the second client must invalidate the mmap() effect,
 with an explicit call at munmap(), and the first client must close the
 fd, calling ION_IOC_FREE.
 This function decrements the reference counter of the handle.
 When it reaches zero, the ion_handle is destroyed, and the data structure
 that manages ION is updated.
 While managing client calls, ION validates input from fd, from client and
 from handler arguments.
 This validation mechanism reduce the probability of undesired access and
 memory leaks.
 Ion_buffers is somewhere similar to DMABUF.
 Both uses anonymous fd, reference counted, as shareable objects.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="top">
<column alignment="center" valignment="top" width="20col%">
<column alignment="left" valignment="top" width="40col%">
<column alignment="left" valignment="top" width="30col%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ION buffers
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMABUF
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Application level MMU
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Alloc and free memory from memory pools in a shareable and trackable way
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
It focus on import, export and syncronization in a consisten way with buffer
 sharing solution for non arm architectures
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Role of Memory manager 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ION replace PMEM as memory pools manager.
 ION heap lists can be extended by the device.
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMABUF is a buffer sharing framework , designed to be integrated with memory
 allocator in contiguous DMA mapping framewors, such as CMA.
 DMABUF exporters can implement custom allocator.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
User Space access control 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ION offers /dev/ion interface to user space program, letting them to alloc
 and share buffers.
 Every user process with ION access can suspend the system overlapping ION
 heap.
 Android chech user and groupID blocking non authorized access to ION heap
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMABUF offers only kernel API.
\end_layout

\begin_layout Plain Layout
Access control is a function of the permissions on device that uses DMABUF
 feature
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Global Client and Buffer Database.
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ION has a driver associated to /dev/ion.
 The device structure has a database that keeps ION buffers allocated, handlers
 and fd, grouped by user client and kernel client.
 ION validates all the client calls to be valid for database rules.
 For instance, an handle can't have two buffers associated.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The debub structure of DMA implements a global hashtable, dma_entry_hash,
 tracking DMA buffers, but only when kernel is build with CONFIG_DMA_API_
\end_layout

\begin_layout Plain Layout
DEBUG option.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cross- architecture usage
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ION usage now is limited on architectures that runs kernel Android
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMABUF usage is cross architecture.
 DMA mapping redesign let his implementation in 9 architectures beside the
 ARM one.
 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="top">
<column alignment="center" valignment="top" width="18col%">
<column alignment="center" valignment="top" width="35col%">
<column alignment="center" valignment="top" width="33col%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ION_buffer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMABUF
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Buffer Syncronization
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ion consider the syncronization problem as an orthogonal problem
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMABUF gives a pair of API for synchronization.
 Buffer user invokes dma_buf_map_
\end_layout

\begin_layout Plain Layout
attachment() everywhere he desires to use buffer for DMA.
 Once he finished using that, signals "endOfDMA" to exporter using dma_buf_unmap
_
\end_layout

\begin_layout Plain Layout
attachment()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Buffer delayed allocation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ION allocs physical memory before the buffer is shared
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMABUF can delay allocation till the first call of dma_buf_map_
\end_layout

\begin_layout Plain Layout
attachment().
 DMA buffer exporter has the opportunity of scans every client attachment,
 collecting all the constraints and choose the most efficient storage
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Integration with Video4
\end_layout

\begin_layout Plain Layout
Linux2 API 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Processes that uses these API tends to use PMEM.
 So, the migration from PMEM to ION has a relatively small impact.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMABUF integration with Video4Linux is hard and asked for lots of modifies
 in DMABUF.
 But in a long time that will be a smart choice, because DMABUF sharing
 mechanism is fitted for DMA, so it is well written for CMA and IOMMU.
 Both of them reduces carveout memory needs to build an Android smartphone.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
OOM Killer
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
Mobile devices become more and more rich of memory over time, due to Moore's
 Law.
 However, there's always a limit over wich memory isn't available, and a
 well form kernel needs some politics to free bunch of memory when needed.
 Android provides an OOM killer, who kills processes using heuristics, developed
 over time.
\begin_inset CommandInset citation
LatexCommand cite
key "OOM_TAMING"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%copincollato dall'articolo!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Major distribution kernels set the default value of /proc/sys/vm/overcommit_memo
ry to zero, which means that processes can request more memory than is currently
 free in the system.
 This is done based on the heuristics that allocated memory is not used
 immediately, and that processes, over their lifetime, also do not use all
 of the memory they allocate.
 Without overcommit, a system will not fully utilize its memory, thus wasting
 some of it.
 Overcommiting memory allows the system to use the memory in a more efficient
 way, but at the risk of OOM situations.
 Programs that asks lots of memory can consume all the system's memory,
 stopping the whole system.
 This can lead to a situation, when memory is so low, that even a single
 page cannot be allocated to a user process, to allow the administrator
 to kill an appropriate task, or to the kernel to carry out important operations
 such as freeing memory.
 In such a situation, the OOM-killer kicks in and identifies the process
 to be killed for the benefit of the rest of the system.
\end_layout

\begin_layout Subsection
OOM euristics
\end_layout

\begin_layout Standard
To facilitate OOM system control, the /proc/<pid>/oom_adj knob was introduced
 to save important processes in the system from being killed, and define
 an order of processes to be killed.
 The possible values of oom_adj range from -17 to +15.
 The higher the score, more likely the associated process is to be killed
 by OOM-killer.
 If oom_adj is set to -17, the process is not considered for OOM-killing.
\end_layout

\begin_layout Standard
Who's Bad? The process to be killed in an out-of-memory situation is selected
 based on its badness score.
 The badness score is reflected in /proc/<pid>/oom_score.
 
\end_layout

\begin_layout Standard
This euristic value is determined on the basis of four characteristics:
\end_layout

\begin_layout Itemize
that the system loses the minimum amount of work done, 
\end_layout

\begin_layout Itemize
recovers a large amount of memory, 
\end_layout

\begin_layout Itemize
doesn't kill any innocent process eating tons of memory, 
\end_layout

\begin_layout Itemize
kills the minimum number of processes (if possible limited to one)
\end_layout

\begin_layout Standard
The badness score is computed using 
\end_layout

\begin_layout Itemize
the original memory size of the process, 
\end_layout

\begin_layout Itemize
its CPU time (utime + stime), 
\end_layout

\begin_layout Itemize
the run time (uptime - start time) 
\end_layout

\begin_layout Itemize
its oom_adj value.
 
\end_layout

\begin_layout Standard
The more memory the process uses, the higher the score.
 The longer a process is alive in the system, the smaller the score.
\end_layout

\begin_layout Standard
Any process unlucky enough to be in the swapoff() system call (which removes
 a swap file from the system) will be selected to be killed first.
 For the rest, the initial memory size becomes the original badness score
 of the process.
 Half of each child's memory size is added to the parent's score if they
 do not share the same memory.
 Thus forking servers are the prime candidates to be killed.
 Having only one "hungry" child will make the parent less preferable than
 the child.
 Finally, the following heuristics are applied to save important processes:
\end_layout

\begin_layout Itemize
if the task has nice value above zero, its score doubles 
\end_layout

\begin_layout Itemize
superuser or direct hardware access tasks (CAP_SYS_ADMIN, CAP_SYS_RESOURCE
 or CAP_SYS_RAWIO) have their score divided by 4.
 This is cumulative, i.e., a super-user task with hardware access would have
 its score divided by 16.
 
\end_layout

\begin_layout Itemize
if OOM condition happened in one cpuset and checked task does not belong
 to that set, its score is divided by 8.
 
\end_layout

\begin_layout Itemize
the resulting score is multiplied by two to the power of oom_adj (i.e.
 points <<= oom_adj when it is positive and points >>= -(oom_adj) otherwise).
 
\end_layout

\begin_layout Itemize
The task with the highest badness score is then selected and its children
 are killed.
 The process itself will be killed in an OOM situation when it does not
 have children.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%che ne dici di un bel grafico riassuntivo qui?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
User space OOM killer control 
\end_layout

\begin_layout Standard
There's a problem in using purely heuristics: value of /proc/<pid>/oom_score
 is dynamic and very difficult to guess.
 Also, it could not be as flexible as an administrator needs.
 It is difficult to determine which process will be killed in case of an
 OOM condition.
 The administrator must adjust the score for every process created, and
 for every process which exits.
 This could be quite a task in a system with quickly-spawning processes.
 In an attempt to make OOM-killer policy implementation easier, a name-based
 solution was proposed.
\end_layout

\begin_layout Standard
With his patch, the process to die first is the one running the program
 whose name is found in /proc/sys/vm/oom_victim.
 A name based solution has its limitations:
\end_layout

\begin_layout Itemize
task name is not a reliable indicator of true name and is truncated in the
 process name fields.
 
\end_layout

\begin_layout Itemize
Moreover, symlinks to executing binaries, but with different names will
 not work with this approach 
\end_layout

\begin_layout Itemize
This approach can specify only one name at a time, ruling out the possibility
 of a hierarchy 
\end_layout

\begin_layout Itemize
There could be multiple processes of the same name but from different binaries.
 
\end_layout

\begin_layout Standard
The behavior boils down to the default current implementation if there is
 no process by the name defined by /proc/sys/vm/oom_victim.
 This increases the number of scans required to find the victim process.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%% da finire la lettura di taming the oom system
\end_layout

\end_inset


\end_layout

\begin_layout Standard
S
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintAll"
bibfiles "Report"
options "savetrees"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{multicols}
\end_layout

\end_inset

 
\end_layout

\end_body
\end_document
