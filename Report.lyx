#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
% VDE Template for EUSAR Papers
% Provided by Barbara Lang und Siegmar Lampe
% University of Bremen, January 2002
% English version by Jens Fischer
% German Aerospace Center (DLR), December 2005
% Additional modifications by Matthias Wei{\ss}
% FGAN, January 2009

%-----------------------------------------------------------------------------
% Type of publication

%-----------------------------------------------------------------------------
% Other packets: Most packets may be downloaded from www.dante.de and
% "tcilatex.tex" can be found at (December 2005):
% http://www.mackichan.com/techtalk/v30/UsingFloat.htm
% Not all packets are necessarily needed:
%\usepackage{ngerman} % in german language if required
\usepackage[nooneline,bf]{caption}% Figure descriptions from left margin
\usepackage{times}\usepackage{multicol}\usepackage{epsfig}\input{tcilatex}
\usepackage{url}\usepackage[numbers]{natbib}
%-----------------------------------------------------------------------------
% Page Setup
\textheight24cm \textwidth17cm \columnsep6mm
\oddsidemargin-5mm                 % depending on print drivers!
\evensidemargin-5mm                % required margin size: 2cm
\headheight0cm \headsep0cm \topmargin0cm \parindent0cm
                  % delete footer and header
%----------------------------------------------------------------------------
% Environment definitions
%-----------------------------------------------------------------------------
% Using Pictures and tables:
% - Instead "table" write "tablehere" without parameters
% - Instead "figure" write "figurehere " without parameters
% - Please insert a blank line before and after \begin{figurehere} ... \end{figurehere}
%
% CAUTION:   The first reference to a figure/table in the text should be formatted fat.
%




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding latin1
\fontencoding T1
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 2
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle empty
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Survey on Android Memory Management System
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Garza Matteo
\end_layout

\begin_layout Standard
Matr.
 755295, (matteo.garza@mail.polimi.it)
\end_layout

\begin_layout Standard
Tania Suarez Legra
\end_layout

\begin_layout Standard
Matr 748927 (tania.suarez@mail.polimi.it)
\end_layout

\begin_layout Standard
\begin_inset space \hspace{}
\length 10ex
\end_inset

 
\end_layout

\begin_layout Standard
\align right

\emph on
Report for the master course of Real Time Operative System (RTOS)
\emph default

\begin_inset Newline newline
\end_inset

 
\emph on
Reviser: PhD.
 Patrick Bellasi (bellasi@elet.polimi.it)
\emph default
 
\end_layout

\begin_layout Standard
Received: April, 01 2011
\begin_inset Newline newline
\end_inset

 
\begin_inset space \hspace{}
\length 10ex
\end_inset


\end_layout

\begin_layout Abstract
Android Operative System
\begin_inset CommandInset citation
LatexCommand cite
key "OVERVIEW"

\end_inset

 is the most diffuse OS in mobile devices.
 In this paper we will analyze how Android manages memory.
 We discuss in particular about application memory and some of the most
 used MMUs used by Android OS.
\end_layout

\begin_layout Standard
\begin_inset VSpace 4ex
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{multicols}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset

2
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Kernel Memory Management
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
Android
\begin_inset CommandInset citation
LatexCommand cite
key "WIKI,OVERVIEW,AndPortal,StatusFeb2012"

\end_inset

 is a Linux-based operative system, written in C and C++.
 Android application software runs on a framework which includes Java-compatible
 libraries.
 Android uses the Dalvik virtual machine with just-in-time compilation to
 run Dalvik dex-code (Dalvik Executable), which is usually translated from
 Java bytecode.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "Android distribution diffusion (July 2012)"

\end_inset

 shows the actual (July 2012)
\begin_inset CommandInset citation
LatexCommand cite
key "WIKI"

\end_inset

 distribution of Android version between devices with this kernel
\begin_inset CommandInset citation
LatexCommand cite
key "GoogleDashboard"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/coach/Dropbox/RTOS/roba su github/Android_chart.png
	scale 30

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Android distribution diffusion (July 2012)"

\end_inset


\end_layout

\begin_layout Standard
We can notice that now the common kernel distributions still use Linux 2.6.x
 kernel and in particular Android 2.3.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "Android structure (in red, linux kernel parts, in green C++ libraries, in blue Dalvik-interpreted Java applications)"

\end_inset

 shows Android System Architecture schema 
\begin_inset CommandInset citation
LatexCommand cite
key "WIKI"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename /home/coach/Dropbox/RTOS/roba su github/System-architecture.jpg
	scale 30

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Android structure (in red, linux kernel parts, in green C++ libraries, in blue Dalvik-interpreted Java applications)"

\end_inset


\end_layout

\begin_layout Standard
Android 
\begin_inset CommandInset citation
LatexCommand cite
key "OVERVIEW"

\end_inset

 provides some modification to main Linux kernel, such as an improved power
 management, ASHMEM virtual memory, some specific-component drivers, and
 a low memory killer.
 The latter's mission is to free memory when the system run Out of Memory
 (OOM).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%-----------------------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% TODO: 
\end_layout

\begin_layout Plain Layout

%- ampliare l'introduzione
\end_layout

\begin_layout Plain Layout

% - rivedere parte su CMA: guardarsi gli altri articoli, condensare le notizie
 importanti
\end_layout

\begin_layout Plain Layout

% - finire ION con gli sviluppi futuri: integrazione CMA con ION.
\end_layout

\begin_layout Plain Layout

% - TUTTA la parte su OOM killer
\end_layout

\begin_layout Plain Layout

% 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Low level management and integration with HW resources
\end_layout

\begin_layout Standard
In this part, we discuss about how the memory has managed in Android devices,
 focusing on generation of large contiguous buffers.
 For most of the releases in Android, it was used PMEM and ASHMEM.
 These kind of drivers are way too simple, and was patched with some SoC
 patches, such as NVMAP for nVidia Tegra devices and CMEM for TI OMAP ones.
 The most important patch was CMA (Contiguous Memory Access), expecially
 with DMABUF patch, developed both by Samsung.
 The most important reason 
\begin_inset CommandInset citation
LatexCommand cite
key "StatusFeb2012"

\end_inset

 is that 
\series bold
PMEM is not fitted to be used massively with graphics
\series default
.
 Graphical devices (such as camera) needs large amount of memory in a very
 short time (or even in real time), so the device need to 
\series bold
avoid memory fragmentation
\series default
, that is space-consuming and mainly time consuming.
 With the release of Android 4.0 (Ice Cream Sandwich) a brand new driver
 has released, ION.
 Thus is needed to 
\series bold
unify etherogeneal MMU approaches in a brand new standardization
\series default
.
 We discuss about differences between ION and CMA approach, and, in the
 state-of-art, we discuss of a future integration between them.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%-----------------------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
PMEM and ASHMEM
\end_layout

\begin_layout Standard
PMEM (Process MEMory)
\begin_inset CommandInset citation
LatexCommand cite
key "AKF"

\end_inset

 is the 
\series bold
first memory driver
\series default
 implemented on Android devices (since G1).
 It is used to manage shared memory regions sufficiently large (from 1 to
 16MB).
\end_layout

\begin_layout Standard
This regions must be physically contiguous between user space and kernel
 drivers (such as GPU, or DSP).
 It was written specifically to be used in a very limited hardware platform,
 and it could be disabled on x86 architectures.
 It works in a very simple way: 
\series bold
it allocs a bunch of memory at boot time
\series default
.
\begin_inset CommandInset citation
LatexCommand cite
key "Dec2011Merging"

\end_inset

This is dedicated memory usable for contiguous buffer.
 As is written above, Pmem is not suitable for massive use of graphics.
 The main problem of PMEM is that 
\series bold
it exports a device to user space
\series default
, giving the applications the right to alloc direcly buffers to be passed
 to drivers.
 Kernel provides only a low level interface to be used by applications,
 thus causing problems of usability and security.
 The majority of application is written using PMEM approach.
\end_layout

\begin_layout Standard
ASHMEM
\begin_inset CommandInset citation
LatexCommand cite
key "ASHMEM"

\end_inset

 (Android SHared MEMory) is a shared memory allocator subsystem, similar
 to POSIX (the classical Linux OS approach), but with a different behavior.
 It also gives to the developer an easier and file-based API.
 It used 
\series bold
named memory
\series default
, releasable by the kernel.
 Apparently, ASHMEM supports low memory devices better than PMEM, because
 it could free shared memory units when it is needed.
 
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="33col%">
<column alignment="center" valignment="top" width="40col%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PMEM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ASHMEM
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Uses physically contiguous addresses
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Uses virtual memory
\end_layout

\end_inset
</cell>
</row>
<row endhead="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
The first process who instantiate a memory heap must keep that till the
 last one of the users won't free the file descriptor.
 Thus to preserve contiguity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Memory is handled by instances (object oriented like).
 It is managed by a reference counter
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
CMA and DMABUF
\end_layout

\begin_layout Standard

\series bold
CMA (Contiguous Memory Allocator)
\begin_inset CommandInset citation
LatexCommand cite
key "CMAdoc"

\end_inset

 is a well known framework
\series default
, which allows setting up 
\series bold
machine-specific configuration
\series default
 for physically-contiguous memory management.
 Memory for devices is then allocated according to that configuration.
 Differently from similar framework, it let regions of 
\series bold
system-reserved memory to be reused in a transparent way
\series default
, letting memory not to be wasted.
 When an alloc is instantiated, this framework migrates all the system page.
 Thus to build a big chunk of physically contiguous memory.
\end_layout

\begin_layout Standard
Why do an OS have to use chunks of memory?
\begin_inset CommandInset citation
LatexCommand cite
key "CMA,RCMA"

\end_inset

 Because 
\series bold
virtual memory tends to fragment pages
\series default
.
 An intensive use of memory let the system not to be able to find contiguous
 memory in a very short time after boot.
 Recently, the requirement of huge pages in applications raises, especially
 for transparent huge pages.
 Another question is devices (such as cameras) that needs DMA over areas
 physically contiguous.
 
\series bold
CMA reserve an huge area of memory at boot time
\series default
, only for huge request of memory.
 For every region, block of pages can be flaggable as three type.
 
\end_layout

\begin_layout Itemize
movable : typically, cache pages or anonymous pages, accessed by page table
 or page cache radix tree 
\end_layout

\begin_layout Itemize
kernel recallable : they can be given back to the kernel by request.
 
\end_layout

\begin_layout Itemize
immovable : these are typically pointer referred pages (such as pages invoked
 by a kmalloc()) 
\end_layout

\begin_layout Standard
The memory manager subsystem 
\series bold
try to keep movable pages as near as possible
\series default
.
 Grouping these pages, kernel try to ensure more and more contiguous free
 space available for further request.
 CMA extends this mechanism.
 It adds a new type of migration (CMA).
 Pages flagged as cma behave like the movable ones, with some differences:
 
\end_layout

\begin_layout Itemize
they are 
\begin_inset Quotes eld
\end_inset

sticky
\begin_inset Quotes erd
\end_inset

, CMA movable pages tends to stay together
\end_layout

\begin_layout Itemize
Their migration type can't be modified by the kernel 
\end_layout

\begin_layout Itemize
In CMA Area, the kernel cannot instantiate pages not movable.
\end_layout

\begin_layout Standard
In other words, memory flagged as CMA keep available for the rest of the
 system with the only restriction to be movable.
 
\end_layout

\begin_layout Standard
When a driver ask for a huge contiguous allocation of memory, 
\series bold
CMA allocator can try to free in his own area some contiguous pages to create
 a buffer large as needed
\series default
.
 When the buffer is no longer requested, memory can be used for other needs.
 CMA can just take only the needed amount of memory without worrying about
 strictly request of alignment.
\end_layout

\begin_layout Standard
CMA patches provides a
\series bold
 set of function that can prepare regions of memory and the creation of
 contest area of a well known size
\series default
 using function cm_alloc and cm_free to keep and release buffers.
 
\series bold
CMA must not be invoked by the driver, but from DMA support functions
\series default
.
 When a driver call a function like dma_alloc_coherent(), CMA should be
 invoked automatically to satisfying the request.
 This should work in normal condition.
\end_layout

\begin_layout Standard
One of the issue about CMA is 
\series bold
how to initially alloc this area of memory
\series default
.
 Current scheme needs that some of special calls should be done by the board
 file system, with a very arm-like approach.
 The idea is to do that without board files.
 The ending result is that it should be at least one iteration of that patch
 set before it will be executed by the mainline.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%E a un certo punto, scrivo di un altro argomento, DMABUF...
 un minimo di introduzione servirebbe :P
\end_layout

\end_inset


\end_layout

\begin_layout Standard
CMA could be extended letting processes to share buffers, and optimizing
 devices using DMA.
 DMABUF is the DMA buffer sharing framework.
\end_layout

\begin_layout Standard
DMA buffers has different request despise of classical allocation of huge
 pages.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="33col%">
<column alignment="center" valignment="middle" width="33col%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMABUF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Transparent Huge Pages
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Normally larger than Transparent Huge Pages.
 10 Mb.
\end_layout

\begin_layout Plain Layout
It could be needed specific memory area, if underlying hardware is sufficiently
 
\begin_inset Quotes eld
\end_inset

strange
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Almost 2Mb large
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMA requires less alignment than THP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2MB of THP needs 2Mb of Alignment
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
ION
\end_layout

\begin_layout Standard
In december 2011,
\series bold
 PMEM is marked as deprecated, and then replaced by ION memory allocator
\series default

\begin_inset CommandInset citation
LatexCommand cite
key "ION"

\end_inset

.
 ION is a memory manager that Google has developed from the 4.0 release of
 And
\series bold
roid (Ice Cream Sandwich), mainly to resolve the interface issue between
 different memory management on each Android device
\series default
.
 In fact, some SoC developer implemented different memory manager.
 We can cite some of them:
\end_layout

\begin_layout Itemize
NVMAP, implemented on nVidia Tegra 
\end_layout

\begin_layout Itemize
CMEM
\begin_inset CommandInset citation
LatexCommand cite
key "CMEM"

\end_inset

, implemented on TI OMAP 
\end_layout

\begin_layout Itemize
HWMEM
\begin_inset CommandInset citation
LatexCommand cite
key "HWMEM"

\end_inset

, implemented on ST-Ericsonn devices 
\end_layout

\begin_layout Standard
All this vendor will pass to ION soon.
\end_layout

\begin_layout Standard
Besides ION being a memory pool manager, it also enables his clients to
 
\series bold
share buffers
\series default
 (so, it works like DMABUF, the DMA buffer sharing framework).
 Like PMEM, 
\series bold
ION manages one or more pools of memory, some of them instantiated at boot
 time or from hardware blocks with specific memory needs
\series default
.
 Some devices like that are GPU, display controllers and cameras.
 ION let his pools to be available as 
\series bold
heap ION
\series default
.
 Every kind of android device can have different ION heaps, depending on
 device memory.
 
\series bold
Physical address and heap dimension can be returned to the programmer only
 if the buffer is physically contiguous
\series default
.
 Buffer can be prepared or deallocated to be used with DMA, or with virtual
 kernel addressing.
 
\series bold
Using a file descriptor, it can be also mapped in the user-space
\series default
.
 There are three kind of allocable ION heap.
 Other ones can be defined by SoC producers (like ION_HEAP_TYPE_SYSTEM_IOMMU
 for hardware blocks equipped with IOMMU driver).
 
\end_layout

\begin_layout Itemize
ION_HEAP_TYPE_SYSTEM
\end_layout

\begin_layout Itemize
ION_HEAP_TYPE_SYSTEM_CONTIG
\end_layout

\begin_layout Itemize
ION_HEAP_TYPE_CARVEOUT : in this case, carveout memory is physically contiguous
 and set as boot.
 
\end_layout

\begin_layout Standard
Typically, in the user-space case, libraries uses ION to alloc large continuous
 buffers.
 For instance, camera library can alloc a capture buffer to be used from
 the camera device.
 Once the buffer is fulfilled with video data, the library gives the buffer
 to kernel to be processed by jpeg encoder block.
 
\series bold
A c/c++ program must have access to '/dev/ion' before it can alloc memory
 thanks to ION
\series default
.
 He can alloc data using file descriptors (fd).
 It can be maximum one client for user process.
\end_layout

\begin_layout Standard
Clients interacts from user-space with ION using 
\series bold
ioctl() system interface
\series default
.
 Android processes can share memory using their fd.
 To obtain shared buffer, the second user process must obtain a client handle
 through a system call open('/dev/ion', O_RDONLY).
 
\series bold
ION manage user space client through process PID
\series default
 (in particular, the 'group leader ' one).
 Fd will be instantiated pointing at the same client structure in the kernel.
 To free a buffer, the second client must invalidate the mmap() effect,
 with an explicit call at munmap(), and the first client must close the
 fd, calling ION_IOC_FREE.
 This function decrements the reference counter of the handle.
 When it reaches zero, the ion_handle is destroyed, and the data structure
 that manages ION is updated.
 While managing client calls, ION validates input from fd, from client and
 from handler arguments.
 This validation mechanism reduce the probability of undesired access and
 memory leaks.
 Ion_buffers is somewhere similar to DMABUF.
 Both uses anonymous fd, reference counted, as shareable objects.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="top">
<column alignment="center" valignment="top" width="12col%">
<column alignment="left" valignment="top" width="35col%">
<column alignment="left" valignment="top" width="40col%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ION buffers
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMABUF
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Application level MMU
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Alloc and free memory from memory pools in a shareable and trackable way
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
It focus on import, export and syncronization in a consisten way with buffer
 sharing solution for non arm architectures
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Role of Memory manager 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ION replace PMEM as memory pools manager.
 ION heap lists can be extended by the device.
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMABUF is a buffer sharing framework , designed to be integrated with memory
 allocator in contiguous DMA mapping framewors, such as CMA.
 DMABUF exporters can implement custom allocator.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
User Space access control 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ION offers /dev/ion interface to user space program, letting them to alloc
 and share buffers.
 Every user process with ION access can suspend the system overlapping ION
 heap.
 Android chech user and groupID blocking non authorized access to ION heap
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMABUF offers only kernel API.
\end_layout

\begin_layout Plain Layout
Access control is a function of the permissions on device that uses DMABUF
 feature
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Global Client and Buffer Database.
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ION has a driver associated to /dev/ion.
 The device structure has a database that keeps ION buffers allocated, handlers
 and fd, grouped by user client and kernel client.
 ION validates all the client calls to be valid for database rules.
 For instance, an handle can't have two buffers associated.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The debub structure of DMA implements a global hashtable, dma_entry_hash,
 tracking DMA buffers, but only when kernel is build with CONFIG_DMA_API_
\end_layout

\begin_layout Plain Layout
DEBUG option.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cross- architecture usage
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ION usage now is limited on architectures that runs kernel Android
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMABUF usage is cross architecture.
 DMA mapping redesign let his implementation in 9 architectures beside the
 ARM one.
 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="top">
<column alignment="center" valignment="top" width="18col%">
<column alignment="center" valignment="top" width="30col%">
<column alignment="center" valignment="top" width="35col%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ION_buffer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMABUF
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Buffer Syncronization
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ion consider the syncronization problem as an orthogonal problem
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMABUF gives a pair of API for synchronization.
 Buffer user invokes dma_buf_map_
\end_layout

\begin_layout Plain Layout
attachment() everywhere he desires to use buffer for DMA.
 Once he finished using that, signals "endOfDMA" to exporter using dma_buf_unmap
_
\end_layout

\begin_layout Plain Layout
attachment()
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Buffer delayed allocation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ION allocs physical memory before the buffer is shared
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMABUF can delay allocation till the first call of dma_buf_map_
\end_layout

\begin_layout Plain Layout
attachment().
 DMA buffer exporter has the opportunity of scans every client attachment,
 collecting all the constraints and choose the most efficient storage
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Integration with Video4
\end_layout

\begin_layout Plain Layout
Linux2 API 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Processes that uses these API tends to use PMEM.
 So, the migration from PMEM to ION has a relatively small impact.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DMABUF integration with Video4Linux is hard and asked for lots of modifies
 in DMABUF.
 But in a long time that will be a smart choice, because DMABUF sharing
 mechanism is fitted for DMA, so it is well written for CMA and IOMMU.
 Both of them reduces carveout memory needs to build an Android smartphone.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
OOM Killer
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
Mobile devices become more and more rich of memory over time, due to Moore's
 Law.
 However, there's always a limit over wich memory isn't available, and a
 well form kernel needs some politics to free bunch of memory when needed.
 Android provides an OOM killer, who kills processes with some heuristics,
 letting memory to be used from someone else.
 OOM killer mechanism are implemented in most of Linux kernel.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%% da ricontrollare! è copincollato!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Major distribution kernels set the default value of /proc/sys/vm/overcommit_memo
ry to zero, which means that 
\series bold
processes can request more memory than is currently free in the system
\series default
.
 This is done based on the heuristics that allocated memory is not used
 immediately, and that processes, over their lifetime, also do not use all
 of the memory they allocate.
 Without overcommit, a system will not fully utilize its memory, thus wasting
 some of it.
 Overcommiting memory allows the system to use the memory in a more efficient
 way, but at the risk of OOM situations.
 Programs who need lots of memory can consume all the system's memory, stopping
 the whole system.
 In such a situation, the OOM-killer kicks in and identifies the process
 to be terminated.
\end_layout

\begin_layout Subsection
OOM Killer parameters
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%% da ricontrollare! mettere elenchi puntati, magari un grafichino che renda
 l'idea
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The process to be killed in an out-of-memory situation is selected based
 on its badness score.
 The badness score is reflected in /proc/<pid>/oom_score.
 This value is determined on the basis of four characteristics:
\end_layout

\begin_layout Itemize
the system loses the minimum amount of work done,
\end_layout

\begin_layout Itemize
recovers a large amount of memory,
\end_layout

\begin_layout Itemize
doesn't kill any innocent process, 
\end_layout

\begin_layout Itemize
and kills the minimum number of processes (if possible limited to one).
 
\end_layout

\begin_layout Standard
The badness score is computed using 
\end_layout

\begin_layout Itemize
the original memory size of the process, 
\end_layout

\begin_layout Itemize
its CPU time (utime + stime), 
\end_layout

\begin_layout Itemize
the run time (uptime - start time) 
\end_layout

\begin_layout Itemize
and its oom_adj value.
 
\end_layout

\begin_layout Standard

\series bold
The more memory the process uses, the higher the score.
 The longer a process is alive in the system, the smaller the score.
\end_layout

\begin_layout Standard
Any process unlucky enough to be in the swapoff() system call (which removes
 a swap file from the system) will be selected to be killed first.
 For the rest, the initial memory size becomes the original badness score
 of the process.
 Half of each child's memory size is added to the parent's score if they
 do not share the same memory.
 Thus forking servers are the prime candidates to be killed.
 Having only one "hungry" child will make the parent less preferable than
 the child.
 Finally, the following heuristics are applied to save important processes:
\end_layout

\begin_layout Itemize
if the task has nice value above zero, its score doubles 
\end_layout

\begin_layout Itemize
superuser or direct hardware access tasks (CAP_SYS_ADMIN, CAP_SYS_RESOURCE
 or CAP_SYS_RAWIO) have their score divided by 4.
 This is cumulative, i.e., a super-user task with hardware access would have
 its score divided by 16.
\end_layout

\begin_layout Itemize
if OOM condition happened in one cpuset and checked task does not belong
 to that set, its score is divided by 8.
\end_layout

\begin_layout Itemize
the resulting score is multiplied by two to the power of oom_adj (i.e.
 points <<= oom_adj when it is positive and points >>= -(oom_adj) otherwise).
 
\end_layout

\begin_layout Standard

\series bold
The task with the highest badness score is then selected and its children
 are killed
\series default
.
 The process itself will be killed in an OOM situation when it does not
 have children.
\end_layout

\begin_layout Subsection
lowmemory driver in Android
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%da ricontrollare in toto!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Android developers required a greater degree of control over the low memory
 situation because the OOM killer does not interfere till late in the low
 memory situation, i.e.
 till all the cache is emptied.
 Android need a solution which would start early while the free memory is
 being completely depleted.
 
\series bold
So developers introduced the "lowmemory" driver
\series default

\begin_inset CommandInset citation
LatexCommand cite
key "OOMTAME"

\end_inset

, which has multiple thresholds of low memory.
 
\end_layout

\begin_layout Standard
In a low-memory situation, 
\series bold
when the first thresholds are met, background processes are notified of
 the problem
\series default
.
 They do not exit, but, instead, save their state.
 This affects the latency when switching applications, because the application
 has to reload on activation.
 On further pressure, the 
\series bold
lowmemory killer kills the non-critical background processes whose state
 had been saved
\series default
 in the previous threshold and, finally, the foreground applications.
\end_layout

\begin_layout Standard
Keeping 
\series bold
multiple low memory triggers
\series default
 gives the processes enough time to free memory from their caches because
 in an OOM situation, user-space processes may not be able to run at all.
 All it takes is a single allocation from the kernel's internal structures,
 or a page fault to make the system run out of memory.
 An earlier notification of a low-memory situation could avoid the OOM situation
 with a little help from the user space applications which respond to low
 memory notifications.
\end_layout

\begin_layout Standard

\series bold
Killing processes based on kernel heuristics is not an optimal solution
\series default
, and these new initiatives of offering better control to the user in selecting
 the process to be the chosen one to terminate are steps to a robust design
 to give more control to the user.
 
\end_layout

\begin_layout Standard
This approach can be improved in many parts, for instance 
\begin_inset CommandInset citation
LatexCommand cite
key "OOMarticle"

\end_inset

 implementing a more efficient way to select the process to be killed, such
 as ordering processes in a red-black tree, improving OOM Killer response
 time11.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%da segare, in quanto non necessaria?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
User space OOM control
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%% da leggere e rivedere!
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

/proc/<pid>/oom_score is a dynamic value, not so much controllable and checkable
 i by the administrator.
 It is difficult to determine which process will be killed in case of an
 OOM condition.
 
\series bold
The system must let the administrator to modify the score
\series default
 for every process created, and for every process which exits.
 In an attempt to make OOM-killer policy implementation easier, a 
\series bold
name-based solution
\series default
 was proposed.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

%by Evgeniy Polyakov.
 Citare nella bibliografia, se possibile
\end_layout

\end_inset

.
 With his patch, the process to die first is the one running the program
 whose name is found in /proc/sys/vm/oom_victim.
 A name based solution has its limitations:
\end_layout

\begin_layout Itemize
task name is not a reliable indicator of true name and is truncated in the
 process name fields.
 Moreover, symlinks to executing binaries, but with different names will
 not work with this approach 
\end_layout

\begin_layout Itemize
This approach can specify only one name at a time, ruling out the possibility
 of a hierarchy 
\end_layout

\begin_layout Itemize
There could be multiple processes of the same name but from different binaries.
 
\end_layout

\begin_layout Itemize
The behavior boils down to the default current implementation if there is
 no process by the name defined by /proc/sys/vm/oom_victim.
 This increases the number of scans required to find the victim process.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%altra citazione necessaria : "Alan Cox disliked this solution, suggesting
 that"
\end_layout

\end_inset

Another possible solution is using containers.
 
\begin_inset ERT
status open

\begin_layout Plain Layout

% citazione di prima: In response to this suggestion, the oom_killer controller,
 contributed by Nikanth Karthikesan, provides control of the sequence of
 processes to be killed when the system runs out of memory.
\end_layout

\end_inset

 The patch introduces an OOM control group (cgroup) with an oom.priority
 field.
 
\series bold
The process to be killed is selected from the processes having the highest
 oom.priority value.
\end_layout

\begin_layout Standard
This approach could have some trouble, in presence of multiple cpuset.
 Consider two cpusets, A and B.
 If a process in cpuset A has a high oom.priority value, it will be killed
 if cpuset B runs out of memory, even though there is enough memory in cpuset
 A.
 
\end_layout

\begin_layout Standard
An interesting outcome of the discussion has been handling OOM situations
 in user space.
 
\series bold
The kernel sends notification to user space, and applications respond by
 dropping their user-space caches
\series default
.
 In case the user-space processes are not able to free enough memory, or
 the processes ignore the kernel's requests to free memory, the kernel will
 kill them.
\begin_inset ERT
status open

\begin_layout Plain Layout

%cita che ti ricita: mem_notify, developed by Kosaki Motohiro, is one such
 attempt made in the past.
 However, the mem_notify patch cannot be applied to versions beyond 2.6.28
 because the memory management reclaiming sequence have changed, but the
 design principles and goals can be reused.
 
\end_layout

\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout

%David Rientjes
\end_layout

\end_inset

 Other hybrid solutions are:
\end_layout

\begin_layout Itemize
the cgroup OOM notifier allows you to attach a task to wait on an OOM condition
 for a collection of tasks.
 This allows userspace to respond to the condition by dropping caches, adding
 nodes to a cpuset, elevating memory controller limits, sending a signal,
 etc.
 It can also defer to the kernel OOM killer as a last resort.
\end_layout

\begin_layout Itemize
/dev/mem_notify allows you to poll() on a device file and be informed of
 low memory events.
 This can include the cgroup oom notifier behavior when a collection of
 tasks is completely out of memory, but can also warn when such a condition
 may be imminent.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "Report"
options "savetrees"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{multicols}
\end_layout

\end_inset

 
\end_layout

\end_body
\end_document
